<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>HelixRun SSE Chat Tester</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    header {
      padding: 8px 12px;
      background: #111827;
      color: #e5e7eb;
      font-size: 14px;
    }
    main {
      flex: 1;
      display: flex;
      gap: 8px;
      padding: 8px;
      box-sizing: border-box;
      background: #f3f4f6;
    }
    .column {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
    }
    .panel {
      background: #ffffff;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
    }
    .panel-header {
      padding: 6px 8px;
      font-size: 12px;
      font-weight: 600;
      background: #f9fafb;
      border-bottom: 1px solid #e5e7eb;
    }
    .panel-body {
      flex: 1;
      overflow: auto;
      padding: 8px;
      background: #f9fafb;
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .panel-body pre {
      margin: 0;
      padding: 6px;
      background: #111827;
      color: #e5e7eb;
      border-radius: 4px;
      font-size: 11px;
      white-space: pre-wrap;
      word-break: break-all;
      overflow-y: auto;
      overflow-x: hidden;
    }
    form {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px;
      border-bottom: 1px solid #e5e7eb;
      background: #f9fafb;
    }
    label {
      font-size: 11px;
      font-weight: 600;
    }
    input[type="text"],
    select,
    textarea {
      width: 100%;
      box-sizing: border-box;
      padding: 6px 8px;
      font-size: 12px;
      border-radius: 4px;
      border: 1px solid #d1d5db;
      font-family: inherit;
      resize: vertical;
    }
    textarea {
      min-height: 60px;
    }
    button {
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background: #2563eb;
      color: white;
      font-weight: 600;
    }
    button[disabled] {
      opacity: 0.6;
      cursor: default;
    }
    .row-inline {
      display: flex;
      gap: 6px;
    }
    .row-inline > div {
      flex: 1;
    }
    .chat-log-entry {
      margin-bottom: 4px;
      font-size: 12px;
    }
    .chat-log-entry span.role {
      font-weight: 600;
    }
  </style>
</head>
<body>
<header>
  HelixRun SSE Chat Tester &mdash; /chat (POST + text/event-stream)
</header>

<main>
  <div class="column">
    <div class="panel">
      <div class="panel-header">Chat</div>
      <form id="chat-form">
        <div>
          <label for="agent-id">Agent</label>
          <select id="agent-id" name="agent_id">
            <option value="simple-tool-agent">simple-tool-agent</option>
            <option value="multi-chain-agent">multi-chain-agent</option>
            <option value="graph-qna-agent">graph-qna-agent</option>
          </select>
        </div>

        <div class="row-inline">
          <div>
            <label for="user-id">User ID</label>
            <input id="user-id" type="text" value="demo-user" />
          </div>
          <div>
            <label for="session-id">Session ID (optional)</label>
            <input id="session-id" type="text" placeholder="session-123" />
          </div>
        </div>

        <div>
          <label for="message">Message</label>
          <textarea id="message">Hello, can you explain what this agent does?</textarea>
        </div>

        <div class="row-inline">
          <button type="submit" id="send-btn">Send &amp; Stream</button>
          <button type="button" id="stop-btn">Stop Stream</button>
        </div>
      </form>

      <div class="panel-body" id="chat-output"></div>
    </div>
  </div>

  <div class="column">
    <div class="panel">
      <div class="panel-header">Raw Events (JSON)</div>
      <div class="panel-body" id="events-output"></div>
    </div>
  </div>
</main>

<script>
  const chatForm = document.getElementById("chat-form");
  const sendBtn = document.getElementById("send-btn");
  const stopBtn = document.getElementById("stop-btn");
  const chatOutput = document.getElementById("chat-output");
  const eventsOutput = document.getElementById("events-output");

  const CHAT_URL = "/chat"; // same origin as Go server

  let currentController = null;

  // Eén doorlopende <pre> voor alle events
  const eventsPre = document.createElement("pre");
  eventsOutput.appendChild(eventsPre);

  // Per-agent / per-node streaming state
  // key -> { node: HTMLElement, text: string }
  const agentStreams = {};

  function resetStreams() {
    for (const k of Object.keys(agentStreams)) {
      delete agentStreams[k];
    }
  }

  function getStreamKey(ev) {
    // Gebruik eerst de author (bv. "clarify", "answer", "simple-tool-agent")
    if (ev.author) return ev.author;
    // Fallback op nodeId als die er is
    if (ev.nodeMetadata && ev.nodeMetadata.nodeId) {
      return ev.nodeMetadata.nodeId;
    }
    // Default
    return "assistant";
  }

  function ensureAgentStream(ev) {
    const key = getStreamKey(ev);
    let stream = agentStreams[key];
    if (!stream) {
      const label = key; // hier kun je eventueel prettify doen
      const node = appendChatLog(label, "");
      stream = { node, text: "" };
      agentStreams[key] = stream;
    }
    return stream;
  }

  function updateAgentText(stream, text) {
    stream.text = text;
    const textSpan = stream.node.querySelector("span.text");
    if (textSpan) {
      textSpan.textContent = text;
      chatOutput.scrollTop = chatOutput.scrollHeight;
    }
  }

  chatForm.addEventListener("submit", (e) => {
    e.preventDefault();
    startChatStream();
  });

  stopBtn.addEventListener("click", () => {
    if (currentController) {
      currentController.abort();
      appendChatLog("system", "[stream aborted]");
    }
  });

  function startChatStream() {
    const agentId = document.getElementById("agent-id").value.trim();
    const userId = document.getElementById("user-id").value.trim() || "anonymous";
    const sessionId = document.getElementById("session-id").value.trim();
    const message = document.getElementById("message").value.trim();

    if (!agentId || !message) {
      alert("Agent ID and message are required.");
      return;
    }

    if (currentController) {
      // Abort any previous stream
      currentController.abort();
    }

    currentController = new AbortController();
    const signal = currentController.signal;

    sendBtn.disabled = true;

    // Nieuwe chat-run → reset agent streams
    appendChatLog("user", message);
    resetStreams();
    clearEventsLog();

    const payload = {
      agent_id: agentId,
      user_id: userId,
      session_id: sessionId || "",
      message: message,
    };

    fetch(CHAT_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "text/event-stream",
      },
      body: JSON.stringify(payload),
      signal,
    })
      .then(async (response) => {
        if (!response.ok) {
          appendChatLog(
            "system",
            `HTTP error: ${response.status} ${response.statusText}`,
          );
          sendBtn.disabled = false;
          return;
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder("utf-8");
        let buffer = "";

        try {
          while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });

            let parts = buffer.split("\n\n");
            buffer = parts.pop() || "";

            for (const rawEvent of parts) {
              handleSSEEvent(rawEvent);
            }
          }
        } catch (err) {
          if (err.name === "AbortError") {
            // user aborted, ignore
          } else {
            appendChatLog("system", "Stream error: " + err.message);
          }
        } finally {
          sendBtn.disabled = false;
          currentController = null;
        }
      })
      .catch((err) => {
        appendChatLog("system", "Fetch error: " + err.message);
        sendBtn.disabled = false;
        currentController = null;
      });
  }
function logDebugEvent(ev) {
  const typ = ev.type || ev.object || "";

  // Skip alle streaming chunks
  if (typ === "chat.completion.chunk") {
    return;
  }

  appendEventRaw(ev);
}
  function handleSSEEvent(rawEvent) {
    // rawEvent is iets als:
    // data: {"type":"chat.completion.chunk", ...UIEvent...}
    const lines = rawEvent.split("\n");
    const dataLines = [];

    for (const line of lines) {
      if (line.startsWith("data:")) {
        dataLines.push(line.slice(5).trimStart());
      }
    }

    if (dataLines.length === 0) {
      return;
    }

    const joined = dataLines.join("\n");

    try {
      const ev = JSON.parse(joined); // ev is nu direct jouw UIEvent
      const typ = ev.type || ev.object || "";

      // Altijd raw UIEvent loggen in rechter paneel
     // Raw events loggen, behalve de streaming chunks
logDebugEvent(ev)

      // 1) Error vanuit handleSSEError (type: "run.error")
      if (typ === "run.error") {
        const errPayload = ev.error || {};
        const msg = errPayload.message || errPayload.Message || "unknown error";
        appendChatLog("system", "Run error: " + msg);
        return;
      }

      // 2) Streaming tokens → linker chatpaneel (per agent/node)
      if (typ === "chat.completion.chunk") {
        const deltaContent =
          typeof ev.contentDelta === "string" ? ev.contentDelta : "";
        if (deltaContent) {
          const stream = ensureAgentStream(ev);
          const newText = (stream.text || "") + deltaContent;
          updateAgentText(stream, newText);
        }
      }

      // 3) Finale completion → UIEvent.content bevat de volledige tekst
      if (typ === "chat.completion") {
        const stream = ensureAgentStream(ev);
        const full =
          typeof ev.content === "string" && ev.content !== ""
            ? ev.content
            : stream.text || "";
        updateAgentText(stream, full);
      }

      // 4) Eventuele andere errors (model/tool/graph) via UIEvent.error
      if (ev.error && typ !== "run.error") {
        const msg = ev.error.message || ev.error.Message || "unknown error";
        appendChatLog("system", "Run error: " + msg);
      }
    } catch (e) {
      // Geen geldige JSON
      // appendEventRaw({ raw: joined, parse_error: e.message });
    }
  }

  function appendChatLog(role, text) {
    const div = document.createElement("div");
    div.className = "chat-log-entry";
    const roleSpan = document.createElement("span");
    roleSpan.className = "role";
    roleSpan.textContent = role + ": ";
    const textSpan = document.createElement("span");
    textSpan.className = "text";
    textSpan.textContent = text;
    div.appendChild(roleSpan);
    div.appendChild(textSpan);
    chatOutput.appendChild(div);
    chatOutput.scrollTop = chatOutput.scrollHeight;
    return div;
  }

  // Pretty JSON in één doorlopend blok (nu direct UIEvent)
  function appendEventRaw(obj) {
    const pretty = JSON.stringify(obj, null, 2);
    eventsPre.textContent += pretty + "\n\n";
    eventsOutput.scrollTop = eventsOutput.scrollHeight;
  }

  function clearEventsLog() {
    eventsPre.textContent = "";
  }
</script>



</body>
</html>
